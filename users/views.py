from django.http.response import HttpResponseRedirect
from django.shortcuts import render, redirect
from django.views import View
from django.contrib import messages
from .forms import UserRegisterForm,ProfileUpdateForm,LoginForm,MyPasswordResetForm,NewPassResetForm
from django.contrib.auth.decorators import login_required
from django.core.mail import EmailMessage, BadHeaderError
from .utils import token_generator
from django.http import HttpResponse
from .models import Users as User
from django.utils.encoding import force_bytes, force_text
from django.utils.http import urlsafe_base64_encode, urlsafe_base64_decode
from django.contrib.sites.shortcuts import get_current_site
from django.template.loader import render_to_string
from django.contrib.auth.tokens import PasswordResetTokenGenerator
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.models import Group
import threading
from django.contrib.auth.forms import PasswordResetForm
from django.db.models.query_utils import Q
from django.views.generic.edit import FormView
from rlcs.decorator import already_authenticated_user


"""
Authors: Robert Lange and Alexander Riccio
Course: CST8333
Date: 2019-12-19

CCS Views that handle all users information contained in Db model
with a custom user model authentication framework. Summarization list below:

Functions and classes:
EmailThread -- Email sending via threading (Class)
register -- Provides user registration process (Function-based view)
RequestPasswordResetEmail - Provision for user passwored reset (Class-based view) 
VerificationView - Handles verification of newly registered user (Class-based view)
CompletePasswordReset - Validates user on password reset (Class-based view)
profile - Provides access to personal profile (Function-based view)
landing - Simple function for redirecting to the RLCS application home page (Function-based view)
LoginView - Provide login credential checking, authentication and redirection to index - landing page (Class-based view)
LogoutView - Calls logout within Djano to log user out (Class-based view)

"""

"""
Due to the synchronous nature of the default Django email process due to Djano handling both the view and email
simultaneously, this proved unacceptable for a positive user experience for sending emails and the process is lengthly as a result. 
By implementing threading of the email process to provide aynchronous operation of email within it's own thread, immediate processing takes 
place since it's within it's own thread which ultamatly speeds up email sending. 
https://youtu.be/7oruVMyE3J0
"""
class EmailThread(threading.Thread):
     
    def __init__(self, email_message):
        self.email_message=email_message
        threading.Thread.__init__(self)

#define run method
    def run(self):
        self.email_message.send()
    
"""
Forms/templates: UserRegisterForm, register.html send_acc_activate.html
Methods: GET/POST
Other: Google reCAPTCHA
Output: Successful registration banner message upon conclusion of submission.
Output other: Email sent to new user

The register Function handles both the GET and POST registration activity while rendering the UserRegisterForm class within crispy_forms_tags 
in the html register.html form.The new user would fill out the form fields which include email address as the primary key for the user
within the custom Users model, a User Name, First name, Last name, password1, password2 as wel as a call to implement
Google's reCAPTCHA to prevent robot like entries. Only when reCAPTCHA has completed verification, the submission is activated.
The form is  generated using a form class in forms.py with the particular class being UserRegisterForm. 
The register function will also check the Users model to see if the user already exists. If so, the user is notified and the registration process
ends. Upon successful registration with a unique identifier, the new user is added, but done so in an inactive state and only when verified, 
the account is activated via the activation process. As part of the process, it sends an email link appened with a security token
to the new user email account. The link along with the token generated by the PasswordResetTokenGenerator class with base64 encoding facilitates 
the use of send_acc_activate.html template where the message is rendered along with the token, then sent asynchronously via the email threading
mechanism to the new user via the EmailThread mechanism. The sites framework provides the domain information - configurable via sites properties 
in the admin page.

Used combination of documentation and Youtube
https://docs.djangoproject.com/en/3.1/topics/auth/customizing/
    
"""
def register(request):
    if request.method == 'POST':
        form = UserRegisterForm(request.POST)
        if form.is_valid():
            user = form.save(commit=False)
            user.is_active = False
            email_address = form.cleaned_data.get('email').lower()
             # Check to see if any users already exist with this email as a username.
            if User.objects.filter(email=email_address).exists():
                messages.error(request, 'This email address is already in use.e')
                return render(request, 'users/register.html', {'form': form, 'activePage': 'register'})
            user.save()
            current_site = get_current_site(request)
            email_subject = 'Activate Your Account'
            uid = urlsafe_base64_encode(force_bytes(user.pk))
            message = render_to_string('users/send_acc_activate.html', {
                'user': user,
                'domain': current_site.domain,
                'uid': uid,
                'token': token_generator.make_token(user),
            })           
            email = EmailMessage(email_subject, message, to=[email_address])
            EmailThread(email).start()
            messages.success(request, f'Account created for {user}. Check your inbox to activate')
            #return redirect ('users:login')
    else:
        form = UserRegisterForm()
    return render(request, 'users/register.html', {'form': form, 'activePage': 'register'})



"""
Forms/templates: MyPasswordResetForm, password_reset.html
Methods: GET/POST
Output: Successful banner message upon conclusion of reset request.
Output other: Email sent to existing user

The RequestPasswordResetEmail class makes use of similar processes of tokenizing and templates containing as that of the register function process
for the password reset functionality. The form is primarily generated using a form class in forms.py - MyPasswordResetForm. Some html 
decoration/styling is done in the password_reset.html template which also contains the crispy_forms_tags for the generated form template. 
Upon request for a password reset, the reset process is initiated only when verified as a current registered user, it then sends
an email link to the user's email address appened with a security token. The link along with the token generated by the PasswordResetTokenGenerator class 
with base64 encoding facilitates the use of password_reset.html template where the message is rendered along with the token, then sent asynchronously via the email threading
to the user via the EmailThread mechanism. The sites framework provides the domain information - configurable via sites properties 
in the admin page.

https://www.ordinarycoders.com/blog/article/django-password-reset
https://www.youtube.com/watch?v=a2Rom1nfHRs

"""
class RequestPasswordResetEmail(View):
    form = MyPasswordResetForm
    template_name = 'users/password_reset.html'
    
    def get(self, request):
        form = self.form(None)
        return render(request, self.template_name, {'form': form})

    def post(self,request):
        form = self.form(request.POST)
        email_address = request.POST['email'].lower()

        context = {
            'values':request.POST
        }
        email_template_name = "users/password_reset.html"

        current_site = get_current_site(request)
 
        user = User.objects.filter(email=email_address)

        if user.exists():
                message = render_to_string('users/send_acc_reset.html', {
                'user': user[0],
                'domain': current_site.domain,
                'uid': urlsafe_base64_encode(force_bytes(user[0].pk)),
                'token': PasswordResetTokenGenerator().make_token(user[0]),
                })

                email_subject = 'Password Reset Your Account'
                email = EmailMessage(email_subject, message, to=[email_address])
                EmailThread(email).start()
                messages.success(request, 'We have sent you an email to reset your password')  
                
                return render(request, self.template_name, {'form': form})   

        else:
            return render(request, "users/password_reset.html",{'form': form})   

"""
Forms/templates: N/A (redirected to login)
Methods: GET
Inputs: <uidb64>/<token>
Output: Successful banner message for account activation completion.

This class is called through the url mapping which also passes via the url, the encoded uid base 64 token. The user is retrieved from the model 
after the token is decoded and checked (via primary key). If the current user is not activated - as it should be for a new user, the is_active 
boolean is set in the users model which then via the Django authentication mechanism, enables the user to log into the application while being
routed via the login screen. A banner message appears between the login template and the banner for 3 seconds notifying to the user that
the account was activated. The sites framework provides the domain information - configurable via sites properties 
in the admin page.


"""

class VerificationView(View):
    def get(self, request, uidb64, token):
        try:
            id = force_text(urlsafe_base64_decode(uidb64))
            user = User.objects.get(pk=id)

            if not token_generator.check_token(user, token):
                return redirect('login'+'?message='+'User already activated')

            if user.is_active:
                return redirect('users:login')
            user.is_active = True
            user.save()
          
            messages.success(request, 'Your account has been activated successfully')
            return redirect('users:login')

        except Exception as ex:
            pass

        return redirect('users:login')


"""
Forms/templates: NewPassResetform, set-new-password.html
Methods: GET/POST
Inputs: <uidb64>/<token>
Output: Successful banner message stating a password reset was sent to the user's email inbox

This class is called through the url mapping which also passes via the url, the encoded uid base 64 token. The user is retrieved from the model 
after the token is decoded and checked (via primary key). The user then initiate the password reset by clicking on the link which contains the token
string then gets directed to the to the form class in forms.py - NewPassResetform which then gets rendered in the set-new-password.html template via
Crispyforms tag along with some local styling added
 A banner message appears between the login template and the banner for 3 seconds notifying to the user that
the account was activated. The sites framework provides the domain information - configurable via sites properties 
in the admin page.


https://youtu.be/a2Rom1nfHRs
https://simpleisbetterthancomplex.com/tutorial/2016/08/24/how-to-create-one-time-link.html

"""
class CompletePasswordReset(View):
    form = NewPassResetForm
    template_name = 'users/set-new-password.html'

    def get(self, request, uidb64, token):
        form = self.form(None)

        context = {
            'uidb64':uidb64,
            'token': token,
            'form': form
        }
        # check to see if user uses the link a second time and invalidate if true
        id = force_text(urlsafe_base64_decode(uidb64))
        user = User.objects.get(pk=id)
        """
        Can't seem to get this to work. PasswordResetTokenGenerator always
        returns false.Tried to add more field in utils, no change
        """
        try:        
            if not PasswordResetTokenGenerator().check_token(user, token):
                messages.error(request, 'Password link is invalid, please request a new one')
                return redirect ('users:login')
        except Exception as identifier:
                #import pdb #setup debugger so you can see what identifier is
                #pdb.set_trace()
                pass
        return render(request,'users/set-new-password.html',context)


    def post(self, request, uidb64, token):
        form = self.form(None)
        context = {
            'uidb64':uidb64,
            'token': token,
            'form': form
        }
        password1 = request.POST['password1']
        password2 = request.POST['password2']

        if password1 != password2:
            messages.error(request, 'Passwords do not match')
            return render(request,'users/set-new-password.html', context)

        if len(password1) < 6:
            messages.error(request, 'Password too short')
            return render(request,'users/set-new-password.html', context)

        try:
            id = force_bytes(urlsafe_base64_decode(uidb64))

            user = User.objects.get(pk=id)
            user.set_password(password1)
            user.save()

            messages.success(request, 'Password reset successfully, you may login with your new password')
            return redirect ('users:login')

        except Exception as identifier:
          #  import pdb #setup debugger so you can see what identifier is
          #  pdb.set_trace()
            messages.error(request, 'Something went wrong, try again')
            return render(request,'users/set-new-password.html', context)

            
"""
Forms/templates: ProfileUpdateForm,profile.html
Methods: GET/POST
Output: Successful banner message for profile being updated

This Function based view is used to render a Profile form where the user can enter their profile information.
When a new user is created, made active via the activation process, directed to login, upon the first time the user logs in,
they are directed to the profile page via the landing Functional view so that they may enter their profile information. The form is generated 
using a form class in forms.py - ProfileUpdateForm. The Crispy form tag renders this along html styling handled in the profile.html template. 
A banner message appears between the profile template and the banner for 3 seconds notifying to the user of their submission entry which
is persisted in the Users model. 

A signal defined in the Users model which adds first_login=True to the request session which is tested in the in the landing page Function view
after the user is authenticated. This only happens for the first login after registration since the user.last_login is None. (no time stamp)

"""
@login_required #login required decorator
def profile(request):
    if request.method == 'POST':
        #print(request.POST)
        form = ProfileUpdateForm(request.POST,instance=request.user)
        if  form.is_valid():
            form.save()
            messages.success(request, f'You profile has been updated')
            form = ProfileUpdateForm() #clear form after submit
            return redirect ('users:profile')
    else:
        form = ProfileUpdateForm(instance=request.user)

    context = {
        'form':form,
        'activePage': 'profile'
    }
    return render(request, 'users/profile.html', context)


"""
Forms/templates: N/A
Methods: GET

This Function based view is used to redirect (taffic cop) the user request to either the profile view, login or landing page.
The redirection is based on the analysis of the user request session which may be modified within the signal of the Users model
class - which tests if the user has a previous time-stamp (explained in the profile view).

Check if logging in the first time
https://stackoverflow.com/questions/49385582/can-i-check-if-a-user-is-logged-in-for-the-first-time-after-this-user-is-logged
"""
def landing(request):
    context={}
    if request.user:
        if request.session.get('first_login'):
            return redirect('users:profile')
        else:
            return redirect('rlcs:home')
    else:
        return redirect('users:login')


"""
Forms/templates: LoginForm, login.html
Methods: GET/Post
Other views: CaseInsensitiveAuth (Class) in cst8333.backends.CustomEmailAuthBackend.CaseInsensitiveAuth (authenticate - Function)

This Class based view is used to provide login and authentication utiling Django authentication mechanism against a custom User's model.
As the default Djano authentication backend is NOT case insenitive with respect to the username and Django by default doesn't utilize
an email field as the user's primary authentication handle, an added backend class CaseInsensitiveAuth is used to faciliate a
this case insentive nature to improve the user login experience via authenticate function.
The Crispy form tag in login.html renders the form class along html styling within the login.html template. 

"""

class LoginView(View):
    form = LoginForm
    template_name = 'users/login.html'
    
    def get(self, request):
        form = self.form(None)
        return render(request, self.template_name, {'form': form})

    def post(self, request):
        user = None
        form = self.form(request.POST)
        
        try:
            referer = request.session['referer_link']
            
            # This is because when you are going to the login link directly, there is no request.path_info
            if referer == None:
                referer = '/'
        except:
            referer = '/'

        if form.is_valid():
            email = form.cleaned_data['email']
            password = form.cleaned_data['password']
            
        #check with cst8333.backends.CustomEmailAuthBackend.CaseInsensitiveAuth
            user = authenticate(email=email, password=password)

        if user is not None:
            if user.is_active:
                login(request, user)
                return HttpResponseRedirect(referer)

        return render(request, self.template_name, {'form': form})
    
"""
Forms/templates: logout.html
Methods: GET

Simplist view (Class) which logs he user out of the application rendering the logout.htm template.

"""

class LogoutView(View):
    template_name = 'users/logout.html'
   
    def get(self, request):
        logout(request)
        return render(request, self.template_name)

